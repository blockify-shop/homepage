/**
 * @remix-run/node v1.0.6
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs');
var fsp = require('fs/promises');
var path = require('path');
var sourceMap = require('source-map');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var fsp__default = /*#__PURE__*/_interopDefaultLegacy(fsp);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);

const ROOT = process.cwd() + path__default["default"].sep;
const SOURCE_PATTERN = /(?<at>\s+at.+)\((?<filename>.+):(?<line>\d+):(?<column>\d+)\)/;
const UNKNOWN_LOCATION_POSITION = "<unknown location>";
async function formatServerError(error) {
  try {
    error.stack = await formatStackTrace(error);
  } catch {}

  return error;
}
async function formatStackTrace(error) {
  var _error$stack;

  const cache = new Map();
  const lines = ((_error$stack = error.stack) === null || _error$stack === void 0 ? void 0 : _error$stack.split("\n")) || [];
  const promises = lines.map(line => mapToSourceFile(cache, line));
  const stack = (await Promise.all(promises)).join("\n") || error.stack;
  return stack;
}
async function mapToSourceFile(cache, stackLine) {
  let match = SOURCE_PATTERN.exec(stackLine);

  if (!(match !== null && match !== void 0 && match.groups)) {
    // doesn't match pattern but may still have a filename
    return relativeFilename(stackLine);
  }

  let {
    at,
    filename
  } = match.groups;
  let line = match.groups.line;
  let column = match.groups.column;
  let mapFilename = `${filename}.map`;
  let smc = cache.get(mapFilename);
  filename = relativeFilename(filename);

  if (!smc) {
    if (await fileExists(mapFilename)) {
      // read source map and setup consumer
      const map = JSON.parse(await fsp__default["default"].readFile(mapFilename, "utf-8"));
      map.sourceRoot = path__default["default"].dirname(mapFilename);
      smc = await new sourceMap.SourceMapConsumer(map);
      cache.set(mapFilename, smc);
    }
  }

  if (smc) {
    const pos = getOriginalSourcePosition(smc, parseInt(line, 10), parseInt(column, 10));

    if (pos.source) {
      filename = relativeFilename(pos.source);
      line = pos.line || "?";
      column = pos.column || "?";
      at = `    at \`${getSourceContentForPosition(smc, pos)}\` `;
    }
  }

  return `${at}(${filename}:${line}:${column})`;
}
function relativeFilename(filename) {
  if (filename.includes("route-module:")) {
    filename = filename.substring(filename.indexOf("route-module:"));
  }

  return filename.replace("route-module:", "").replace(ROOT, "./");
}
function getOriginalSourcePosition(smc, line, column) {
  return smc.originalPositionFor({
    line,
    column
  });
}
function getSourceContentForPosition(smc, pos) {
  let src = null;

  if (pos !== null && pos !== void 0 && pos.source && typeof pos.line === "number") {
    src = smc.sourceContentFor(pos.source);
  }

  if (!src) {
    return UNKNOWN_LOCATION_POSITION;
  }

  return src.split("\n")[pos.line - 1].trim();
}

function fileExists(filename) {
  return fsp__default["default"].access(filename, fs__default["default"].constants.F_OK).then(() => true).catch(() => false);
}

exports.UNKNOWN_LOCATION_POSITION = UNKNOWN_LOCATION_POSITION;
exports.formatServerError = formatServerError;
exports.formatStackTrace = formatStackTrace;
exports.getOriginalSourcePosition = getOriginalSourcePosition;
exports.getSourceContentForPosition = getSourceContentForPosition;
exports.mapToSourceFile = mapToSourceFile;
exports.relativeFilename = relativeFilename;
