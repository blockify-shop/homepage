/**
 * @remix-run/react v1.0.6
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var routeModules = require('./routeModules.js');
var data = require('./data.js');
var transition = require('./transition.js');
var links = require('./links.js');
var invariant = require('./invariant.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

function createClientRoute(entryRoute, routeModulesCache, Component) {
  return {
    caseSensitive: !!entryRoute.caseSensitive,
    element: /*#__PURE__*/React__default["default"].createElement(Component, {
      id: entryRoute.id
    }),
    id: entryRoute.id,
    path: entryRoute.path,
    index: entryRoute.index,
    module: entryRoute.module,
    loader: createLoader(entryRoute, routeModulesCache),
    action: createAction(entryRoute),
    shouldReload: createShouldReload(entryRoute, routeModulesCache),
    ErrorBoundary: entryRoute.hasErrorBoundary,
    CatchBoundary: entryRoute.hasCatchBoundary,
    hasLoader: entryRoute.hasLoader
  };
}
function createClientRoutes(routeManifest, routeModulesCache, Component, parentId) {
  return Object.keys(routeManifest).filter(key => routeManifest[key].parentId === parentId).map(key => {
    let route = createClientRoute(routeManifest[key], routeModulesCache, Component);
    let children = createClientRoutes(routeManifest, routeModulesCache, Component, route.id);
    if (children.length > 0) route.children = children;
    return route;
  });
}

function createShouldReload(route, routeModules) {
  let shouldReload = arg => {
    let module = routeModules[route.id];
    invariant(module, `Expected route module to be loaded for ${route.id}`);

    if (module.unstable_shouldReload) {
      return module.unstable_shouldReload(arg);
    }

    return true;
  };

  return shouldReload;
}

async function loadRouteModuleWithBlockingLinks(route, routeModules$1) {
  let routeModule = await routeModules.loadRouteModule(route, routeModules$1);
  await links.prefetchStyleLinks(routeModule);
  return routeModule;
}

function createLoader(route, routeModules) {
  let loader = async ({
    url,
    signal,
    submission
  }) => {
    if (route.hasLoader) {
      let [result] = await Promise.all([data.fetchData(url, route.id, signal, submission), loadRouteModuleWithBlockingLinks(route, routeModules)]);
      if (result instanceof Error) throw result;
      let redirect = await checkRedirect(result);
      if (redirect) return redirect;

      if (data.isCatchResponse(result)) {
        throw new transition.CatchValue(result.status, result.statusText, await data.extractData(result.clone()));
      }

      let data$1 = await data.extractData(result);
      return data$1;
    } else {
      await loadRouteModuleWithBlockingLinks(route, routeModules);
    }
  };

  return loader;
}

function createAction(route) {
  if (!route.hasAction) return undefined;

  let action = async ({
    url,
    signal,
    submission
  }) => {
    let result = await data.fetchData(url, route.id, signal, submission);

    if (result instanceof Error) {
      throw result;
    }

    if (data.isCatchResponse(result)) {
      throw new transition.CatchValue(result.status, result.statusText, await data.extractData(result.clone()));
    }

    let redirect = await checkRedirect(result);
    if (redirect) return redirect;
    return data.extractData(result);
  };

  return action;
}

async function checkRedirect(response) {
  if (data.isRedirectResponse(response)) {
    let url = new URL(response.headers.get("X-Remix-Redirect"), window.location.origin);

    if (url.origin !== window.location.origin) {
      await new Promise(() => {
        window.location.replace(url.href);
      });
    } else {
      return new transition.TransitionRedirect(url.pathname + url.search);
    }
  }

  return null;
}

exports.createClientRoute = createClientRoute;
exports.createClientRoutes = createClientRoutes;
