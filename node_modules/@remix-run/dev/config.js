/**
 * @remix-run/dev v1.0.6
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs');
var path = require('path');
var routes = require('./config/routes.js');
var routesConvention = require('./config/routesConvention.js');
var serverModes = require('./config/serverModes.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var path__namespace = /*#__PURE__*/_interopNamespace(path);

/**
 * Returns a fully resolved config object from the remix.config.js in the given
 * root directory.
 */
async function readConfig(remixRoot, serverMode = serverModes.ServerMode.Production) {
  if (!remixRoot) {
    remixRoot = process.env.REMIX_ROOT || process.cwd();
  }

  if (!serverModes.isValidServerMode(serverMode)) {
    throw new Error(`Invalid server mode "${serverMode}"`);
  }

  let rootDirectory = path__namespace.resolve(remixRoot);
  let configFile = path__namespace.resolve(rootDirectory, "remix.config.js");
  let appConfig;

  try {
    appConfig = require(configFile);
  } catch (error) {
    throw new Error(`Error loading Remix config in ${configFile}`);
  }

  let appDirectory = path__namespace.resolve(rootDirectory, appConfig.appDirectory || "app");
  let cacheDirectory = path__namespace.resolve(rootDirectory, appConfig.cacheDirectory || ".cache");
  let entryClientFile = findEntry(appDirectory, "entry.client");

  if (!entryClientFile) {
    throw new Error(`Missing "entry.client" file in ${appDirectory}`);
  }

  let entryServerFile = findEntry(appDirectory, "entry.server");

  if (!entryServerFile) {
    throw new Error(`Missing "entry.server" file in ${appDirectory}`);
  }

  let serverBuildDirectory = path__namespace.resolve(rootDirectory, appConfig.serverBuildDirectory || "build");
  let assetsBuildDirectory = path__namespace.resolve(rootDirectory, appConfig.assetsBuildDirectory || appConfig.browserBuildDirectory || path__namespace.join("public", "build"));
  let devServerPort = appConfig.devServerPort || 8002;
  let devServerBroadcastDelay = appConfig.devServerBroadcastDelay || 0;
  let publicPath = addTrailingSlash(appConfig.publicPath || "/build/");
  let rootRouteFile = findEntry(appDirectory, "root");

  if (!rootRouteFile) {
    throw new Error(`Missing "root" route file in ${appDirectory}`);
  }

  let routes$1 = {
    root: {
      path: "",
      id: "root",
      file: rootRouteFile
    }
  };

  if (fs__namespace.existsSync(path__namespace.resolve(appDirectory, "routes"))) {
    let conventionalRoutes = routesConvention.defineConventionalRoutes(appDirectory);

    for (let key of Object.keys(conventionalRoutes)) {
      let route = conventionalRoutes[key];
      routes$1[route.id] = { ...route,
        parentId: route.parentId || "root"
      };
    }
  }

  if (appConfig.routes) {
    let manualRoutes = await appConfig.routes(routes.defineRoutes);

    for (let key of Object.keys(manualRoutes)) {
      let route = manualRoutes[key];
      routes$1[route.id] = { ...route,
        parentId: route.parentId || "root"
      };
    }
  }

  return {
    appDirectory,
    cacheDirectory,
    entryClientFile,
    entryServerFile,
    devServerPort,
    devServerBroadcastDelay,
    assetsBuildDirectory,
    publicPath,
    rootDirectory,
    routes: routes$1,
    serverBuildDirectory,
    serverMode,
    mdx: appConfig.mdx
  };
}

function addTrailingSlash(path) {
  return path.endsWith("/") ? path : path + "/";
}

const entryExts = [".js", ".jsx", ".ts", ".tsx"];

function findEntry(dir, basename) {
  for (let ext of entryExts) {
    let file = path__namespace.resolve(dir, basename + ext);
    if (fs__namespace.existsSync(file)) return path__namespace.relative(dir, file);
  }

  return undefined;
}

exports.readConfig = readConfig;
