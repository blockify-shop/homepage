/**
 * @remix-run/dev v1.0.6
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var path = require('path');
var fse = require('fs-extra');
var signalExit = require('signal-exit');
var prettyMs = require('pretty-ms');
var WebSocket = require('ws');
var build$1 = require('../build.js');
var compiler = require('../compiler.js');
var config = require('../config.js');
var format = require('../config/format.js');
var setup$1 = require('../setup.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespace(path);
var fse__namespace = /*#__PURE__*/_interopNamespace(fse);
var signalExit__default = /*#__PURE__*/_interopDefaultLegacy(signalExit);
var prettyMs__default = /*#__PURE__*/_interopDefaultLegacy(prettyMs);
var WebSocket__default = /*#__PURE__*/_interopDefaultLegacy(WebSocket);

async function setup(platformArg) {
  let platform = setup$1.isSetupPlatform(platformArg) ? platformArg : setup$1.SetupPlatform.Node;
  await setup$1.setupRemix(platform);
  console.log(`Successfully setup Remix for ${platform}.`);
}
async function routes(remixRoot, formatArg) {
  let config$1 = await config.readConfig(remixRoot);
  let format$1 = format.isRoutesFormat(formatArg) ? formatArg : format.RoutesFormat.jsx;
  console.log(format.formatRoutes(config$1.routes, format$1));
}
async function build(remixRoot, modeArg, sourcemap = false) {
  let mode = build$1.isBuildMode(modeArg) ? modeArg : build$1.BuildMode.Production;
  console.log(`Building Remix app in ${mode} mode...`);

  if (modeArg === build$1.BuildMode.Production && sourcemap) {
    console.warn("\n⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️");
    console.warn("You have enabled source maps in production. This will make your server side code visible to the public and is highly discouraged! If you insist, please ensure you are using environment variables for secrets and not hard-coding them into your source!");
    console.warn("⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️\n");
  }

  let start = Date.now();
  let config$1 = await config.readConfig(remixRoot);
  await compiler.build(config$1, {
    mode: mode,
    sourcemap
  });
  console.log(`Built in ${prettyMs__default["default"](Date.now() - start)}`);
}
async function watch(remixRootOrConfig, modeArg, callbacks) {
  let {
    onInitialBuild,
    onRebuildStart
  } = callbacks || {};
  let mode = build$1.isBuildMode(modeArg) ? modeArg : build$1.BuildMode.Development;
  console.log(`Watching Remix app in ${mode} mode...`);
  let start = Date.now();
  let config$1 = typeof remixRootOrConfig === "object" ? remixRootOrConfig : await config.readConfig(remixRootOrConfig);
  let wss = new WebSocket__default["default"].Server({
    port: config$1.devServerPort
  });

  function broadcast(event) {
    setTimeout(() => {
      wss.clients.forEach(client => {
        if (client.readyState === WebSocket__default["default"].OPEN) {
          client.send(JSON.stringify(event));
        }
      });
    }, config$1.devServerBroadcastDelay);
  }

  function log(_message) {
    let message = `💿 ${_message}`;
    console.log(message);
    broadcast({
      type: "LOG",
      message
    });
  }

  let closeWatcher = await compiler.watch(config$1, {
    mode,
    onInitialBuild,

    onRebuildStart() {
      start = Date.now();
      onRebuildStart && onRebuildStart();
      log("Rebuilding...");
    },

    onRebuildFinish() {
      log(`Rebuilt in ${prettyMs__default["default"](Date.now() - start)}`);
      broadcast({
        type: "RELOAD"
      });
    },

    onFileCreated(file) {
      log(`File created: ${path__namespace.relative(process.cwd(), file)}`);
    },

    onFileChanged(file) {
      log(`File changed: ${path__namespace.relative(process.cwd(), file)}`);
    },

    onFileDeleted(file) {
      log(`File deleted: ${path__namespace.relative(process.cwd(), file)}`);
    }

  });
  console.log(`💿 Built in ${prettyMs__default["default"](Date.now() - start)}`);
  let resolve;
  signalExit__default["default"](() => {
    resolve();
  });
  return new Promise(r => {
    resolve = r;
  }).then(async () => {
    wss.close();
    await closeWatcher();
    fse__namespace.emptyDirSync(config$1.assetsBuildDirectory);
    fse__namespace.emptyDirSync(config$1.serverBuildDirectory);
  });
}
async function dev(remixRoot, modeArg) {
  // TODO: Warn about the need to install @remix-run/serve if it isn't there?
  let createApp;
  let express;

  try {
    let serve = require("@remix-run/serve");

    createApp = serve.createApp;
    express = require("express");
  } catch (err) {
    throw new Error("Could not locate @remix-run/serve. Please verify you have it installed to use the dev command.");
  }

  let config$1 = await config.readConfig(remixRoot);
  let mode = build$1.isBuildMode(modeArg) ? modeArg : build$1.BuildMode.Development;
  let port = process.env.PORT || 3000;
  let app = express();
  app.use((_, __, next) => {
    purgeAppRequireCache(config$1.serverBuildDirectory);
    next();
  });
  app.use(createApp(config$1.serverBuildDirectory, mode));
  let server = null;

  try {
    await watch(config$1, mode, {
      onInitialBuild: () => {
        server = app.listen(port, () => {
          console.log(`Remix App Server started at http://localhost:${port}`);
        });
      }
    });
  } finally {
    var _server;

    (_server = server) === null || _server === void 0 ? void 0 : _server.close();
  }
}

function purgeAppRequireCache(buildPath) {
  for (let key in require.cache) {
    if (key.startsWith(buildPath)) {
      delete require.cache[key];
    }
  }
}

exports.build = build;
exports.dev = dev;
exports.routes = routes;
exports.setup = setup;
exports.watch = watch;
