/**
 * @remix-run/dev v1.0.6
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs');
var path = require('path');
var module$1 = require('module');
var esbuild = require('esbuild');
var debounce = require('lodash.debounce');
var chokidar = require('chokidar');
var build$1 = require('./build.js');
var config = require('./config.js');
var invariant = require('./invariant.js');
var warnings = require('./warnings.js');
var assets = require('./compiler/assets.js');
var dependencies = require('./compiler/dependencies.js');
var loaders = require('./compiler/loaders.js');
var mdx = require('./compiler/plugins/mdx.js');
var routes = require('./compiler/routes.js');
var fs$1 = require('./compiler/utils/fs.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespace(path);
var esbuild__namespace = /*#__PURE__*/_interopNamespace(esbuild);
var debounce__default = /*#__PURE__*/_interopDefaultLegacy(debounce);
var chokidar__default = /*#__PURE__*/_interopDefaultLegacy(chokidar);

// directory in the same place relative to this file. It is eventually injected
// as a source file when building the app.

const reactShim = path__namespace.resolve(__dirname, "compiler/shims/react.ts");

function defaultWarningHandler(message, key) {
  warnings.warnOnce(false, message, key);
}

function defaultBuildFailureHandler(failure) {
  if ("warnings" in failure || "errors" in failure) {
    if (failure.warnings) {
      let messages = esbuild__namespace.formatMessagesSync(failure.warnings, {
        kind: "warning",
        color: true
      });
      console.warn(...messages);
    }

    if (failure.errors) {
      let messages = esbuild__namespace.formatMessagesSync(failure.errors, {
        kind: "error",
        color: true
      });
      console.error(...messages);
    }
  }

  console.error((failure === null || failure === void 0 ? void 0 : failure.message) || "An unknown build error occured");
}

async function build(config, {
  mode = build$1.BuildMode.Production,
  target = build$1.BuildTarget.Node14,
  sourcemap = false,
  onWarning = defaultWarningHandler,
  onBuildFailure = defaultBuildFailureHandler
} = {}) {
  await buildEverything(config, {
    mode,
    target,
    sourcemap,
    onWarning,
    onBuildFailure
  });
}
async function watch(config$1, {
  mode = build$1.BuildMode.Development,
  target = build$1.BuildTarget.Node14,
  sourcemap = true,
  onWarning = defaultWarningHandler,
  onBuildFailure = defaultBuildFailureHandler,
  onRebuildStart,
  onRebuildFinish,
  onFileCreated,
  onFileChanged,
  onFileDeleted,
  onInitialBuild
} = {}) {
  let options = {
    mode,
    target,
    sourcemap,
    onBuildFailure,
    onWarning,
    incremental: true
  };
  let [browserBuild, serverBuild] = await buildEverything(config$1, options);
  let initialBuildComplete = !!browserBuild && !!serverBuild;

  if (initialBuildComplete) {
    onInitialBuild === null || onInitialBuild === void 0 ? void 0 : onInitialBuild();
  }

  function disposeBuilders() {
    var _browserBuild, _browserBuild$rebuild, _serverBuild, _serverBuild$rebuild;

    (_browserBuild = browserBuild) === null || _browserBuild === void 0 ? void 0 : (_browserBuild$rebuild = _browserBuild.rebuild) === null || _browserBuild$rebuild === void 0 ? void 0 : _browserBuild$rebuild.dispose();
    (_serverBuild = serverBuild) === null || _serverBuild === void 0 ? void 0 : (_serverBuild$rebuild = _serverBuild.rebuild) === null || _serverBuild$rebuild === void 0 ? void 0 : _serverBuild$rebuild.dispose();
    browserBuild = undefined;
    serverBuild = undefined;
  }

  let restartBuilders = debounce__default["default"](async newConfig => {
    disposeBuilders();

    try {
      newConfig = await config.readConfig(config$1.rootDirectory);
    } catch (error) {
      onBuildFailure(error);
      return;
    }

    config$1 = newConfig;
    if (onRebuildStart) onRebuildStart();
    let builders = await buildEverything(config$1, options);
    if (onRebuildFinish) onRebuildFinish();
    browserBuild = builders[0];
    serverBuild = builders[1];
  }, 500);
  let rebuildEverything = debounce__default["default"](async () => {
    var _browserBuild2, _serverBuild2;

    if (onRebuildStart) onRebuildStart();

    if (!((_browserBuild2 = browserBuild) !== null && _browserBuild2 !== void 0 && _browserBuild2.rebuild) || !((_serverBuild2 = serverBuild) !== null && _serverBuild2 !== void 0 && _serverBuild2.rebuild)) {
      disposeBuilders();

      try {
        [browserBuild, serverBuild] = await buildEverything(config$1, options);

        if (!initialBuildComplete) {
          initialBuildComplete = !!browserBuild && !!serverBuild;

          if (initialBuildComplete) {
            onInitialBuild === null || onInitialBuild === void 0 ? void 0 : onInitialBuild();
          }
        }

        if (onRebuildFinish) onRebuildFinish();
      } catch (err) {
        onBuildFailure(err);
      }

      return;
    }

    await Promise.all([// If we get here and can't call rebuild something went wrong and we
    // should probably blow as it's not really recoverable.
    browserBuild.rebuild().then(build => generateManifests(config$1, build.metafile)), serverBuild.rebuild()]).catch(err => {
      disposeBuilders();
      onBuildFailure(err);
    });
    if (onRebuildFinish) onRebuildFinish();
  }, 100);
  let watcher = chokidar__default["default"].watch(config$1.appDirectory, {
    persistent: true,
    ignoreInitial: true,
    awaitWriteFinish: {
      stabilityThreshold: 100,
      pollInterval: 100
    }
  }).on("error", error => console.error(error)).on("change", async file => {
    if (onFileChanged) onFileChanged(file);
    await rebuildEverything();
  }).on("add", async file => {
    if (onFileCreated) onFileCreated(file);
    let newConfig;

    try {
      newConfig = await config.readConfig(config$1.rootDirectory);
    } catch (error) {
      onBuildFailure(error);
      return;
    }

    if (isEntryPoint(newConfig, file)) {
      await restartBuilders(newConfig);
    } else {
      await rebuildEverything();
    }
  }).on("unlink", async file => {
    if (onFileDeleted) onFileDeleted(file);

    if (isEntryPoint(config$1, file)) {
      await restartBuilders();
    } else {
      await rebuildEverything();
    }
  });
  return async () => {
    await watcher.close().catch(() => {});
    disposeBuilders();
  };
}

function isEntryPoint(config, file) {
  let appFile = path__namespace.relative(config.appDirectory, file);

  if (appFile === config.entryClientFile || appFile === config.entryServerFile) {
    return true;
  }

  for (let key in config.routes) {
    if (appFile === config.routes[key].file) return true;
  }

  return false;
} ///////////////////////////////////////////////////////////////////////////////


async function buildEverything(config, options) {
  // TODO:
  // When building for node, we build both the browser and server builds in
  // parallel and emit the asset manifest as a separate file in the output
  // directory.
  // When building for Cloudflare Workers, we need to run the browser and server
  // builds serially so we can inline the asset manifest into the server build
  // in a single JavaScript file.
  try {
    let browserBuildPromise = createBrowserBuild(config, options);
    let serverBuildPromise = createServerBuild(config, options);
    return await Promise.all([browserBuildPromise.then(async build => {
      await generateManifests(config, build.metafile);
      return build;
    }), serverBuildPromise]);
  } catch (err) {
    options.onBuildFailure(err);
    return [undefined, undefined];
  }
}

async function createBrowserBuild(config, options) {
  // For the browser build, exclude node built-ins that don't have a
  // browser-safe alternative installed in node_modules. Nothing should
  // *actually* be external in the browser build (we want to bundle all deps) so
  // this is really just making sure we don't accidentally have any dependencies
  // on node built-ins in browser bundles.
  let dependencies$1 = Object.keys(await dependencies.getAppDependencies(config));
  let externals = module$1.builtinModules.filter(mod => !dependencies$1.includes(mod));
  let fakeBuiltins = module$1.builtinModules.filter(mod => dependencies$1.includes(mod));

  if (fakeBuiltins.length > 0) {
    throw new Error(`It appears you're using a module that is built in to node, but you installed it as a dependency which could cause problems. Please remove ${fakeBuiltins.join(", ")} before continuing.`);
  }

  let entryPoints = {
    "entry.client": path__namespace.resolve(config.appDirectory, config.entryClientFile)
  };

  for (let id of Object.keys(config.routes)) {
    // All route entry points are virtual modules that will be loaded by the
    // browserEntryPointsPlugin. This allows us to tree-shake server-only code
    // that we don't want to run in the browser (i.e. action & loader).
    entryPoints[id] = path__namespace.resolve(config.appDirectory, config.routes[id].file) + "?browser";
  }

  return esbuild__namespace.build({
    entryPoints,
    outdir: config.assetsBuildDirectory,
    platform: "browser",
    format: "esm",
    external: externals,
    inject: [reactShim],
    loader: loaders.loaders,
    bundle: true,
    logLevel: "silent",
    splitting: true,
    sourcemap: options.sourcemap,
    metafile: true,
    incremental: options.incremental,
    minify: options.mode === build$1.BuildMode.Production,
    entryNames: "[dir]/[name]-[hash]",
    chunkNames: "_shared/[name]-[hash]",
    assetNames: "_assets/[name]-[hash]",
    publicPath: config.publicPath,
    define: {
      "process.env.NODE_ENV": JSON.stringify(options.mode)
    },
    plugins: [mdx.mdxPlugin(config), browserRouteModulesPlugin(config, /\?browser$/), emptyModulesPlugin(config, /\.server(\.[jt]sx?)?$/)]
  });
}

async function createServerBuild(config, options) {
  let dependencies$1 = Object.keys(await dependencies.getAppDependencies(config));
  return esbuild__namespace.build({
    stdin: {
      contents: getServerEntryPointModule(config, options),
      resolveDir: config.serverBuildDirectory
    },
    outfile: path__namespace.resolve(config.serverBuildDirectory, "index.js"),
    platform: "node",
    format: "cjs",
    target: options.target,
    inject: [reactShim],
    loader: loaders.loaders,
    bundle: true,
    logLevel: "silent",
    incremental: options.incremental,
    sourcemap: true,
    // The server build needs to know how to generate asset URLs for imports
    // of CSS and other files.
    assetNames: "_assets/[name]-[hash]",
    publicPath: config.publicPath,
    plugins: [mdx.mdxPlugin(config), serverRouteModulesPlugin(config), emptyModulesPlugin(config, /\.client(\.[jt]sx?)?$/), manualExternalsPlugin((id, importer) => {
      // assets.json is external because this build runs in parallel with the
      // browser build and it's not there yet.
      if (id === "./assets.json" && importer === "<stdin>") return true; // Mark all bare imports as external. They will be require()'d at
      // runtime from node_modules.

      if (isBareModuleId(id)) {
        let packageName = getNpmPackageName(id);

        if (!/\bnode_modules\b/.test(importer) && !module$1.builtinModules.includes(packageName) && !dependencies$1.includes(packageName)) {
          options.onWarning(`The path "${id}" is imported in ` + `${path__namespace.relative(process.cwd(), importer)} but ` + `${packageName} is not listed in your package.json dependencies. ` + `Did you forget to install it?`, packageName);
        } // allow importing css files for bundling / hashing from node_modules.


        if (id.endsWith(".css")) return false;
        return true;
      }

      return false;
    })]
  });
}

function isBareModuleId(id) {
  return !id.startsWith(".") && !id.startsWith("~") && !path__namespace.isAbsolute(id);
}

function getNpmPackageName(id) {
  let split = id.split("/");
  let packageName = split[0];
  if (packageName.startsWith("@")) packageName += `/${split[1]}`;
  return packageName;
}

async function generateManifests(config, metafile) {
  let assetsManifest = await assets.createAssetsManifest(config, metafile);
  let filename = `manifest-${assetsManifest.version.toUpperCase()}.js`;
  assetsManifest.url = config.publicPath + filename;
  return Promise.all([fs$1.writeFileSafe(path__namespace.join(config.assetsBuildDirectory, filename), `window.__remixManifest=${JSON.stringify(assetsManifest)};`), fs$1.writeFileSafe(path__namespace.join(config.serverBuildDirectory, "assets.json"), JSON.stringify(assetsManifest, null, 2))]);
}

function getServerEntryPointModule(config, options) {
  switch (options.target) {
    case build$1.BuildTarget.Node14:
      return `
import * as entryServer from ${JSON.stringify(path__namespace.resolve(config.appDirectory, config.entryServerFile))};
${Object.keys(config.routes).map((key, index) => {
        let route = config.routes[key];
        return `import * as route${index} from ${JSON.stringify(path__namespace.resolve(config.appDirectory, route.file))};`;
      }).join("\n")}
export { default as assets } from "./assets.json";
export const entry = { module: entryServer };
export const routes = {
  ${Object.keys(config.routes).map((key, index) => {
        let route = config.routes[key];
        return `${JSON.stringify(key)}: {
    id: ${JSON.stringify(route.id)},
    parentId: ${JSON.stringify(route.parentId)},
    path: ${JSON.stringify(route.path)},
    index: ${JSON.stringify(route.index)},
    caseSensitive: ${JSON.stringify(route.caseSensitive)},
    module: route${index}
  }`;
      }).join(",\n  ")}
};`;

    default:
      throw new Error(`Cannot generate server entry point module for target: ${options.target}`);
  }
}

const browserSafeRouteExports = {
  CatchBoundary: true,
  ErrorBoundary: true,
  default: true,
  handle: true,
  links: true,
  meta: true,
  unstable_shouldReload: true
};
/**
 * This plugin loads route modules for the browser build, using module shims
 * that re-export only the route module exports that are safe for the browser.
 */

function browserRouteModulesPlugin(config, suffixMatcher) {
  return {
    name: "browser-route-modules",

    async setup(build) {
      let routesByFile = Object.keys(config.routes).reduce((map, key) => {
        let route = config.routes[key];
        map.set(path__namespace.resolve(config.appDirectory, route.file), route);
        return map;
      }, new Map());
      build.onResolve({
        filter: suffixMatcher
      }, args => {
        return {
          path: args.path,
          namespace: "browser-route-module"
        };
      });
      build.onLoad({
        filter: suffixMatcher,
        namespace: "browser-route-module"
      }, async args => {
        let file = args.path.replace(suffixMatcher, "");
        let route = routesByFile.get(file);
        invariant["default"](route, `Cannot get route by path: ${args.path}`);
        let exports;

        try {
          exports = (await routes.getRouteModuleExportsCached(config, route.id)).filter(ex => !!browserSafeRouteExports[ex]);
        } catch (error) {
          return {
            errors: [{
              text: error.message,
              pluginName: "browser-route-module"
            }]
          };
        }

        let spec = exports.length > 0 ? `{ ${exports.join(", ")} }` : "*";
        let contents = `export ${spec} from ${JSON.stringify(file)};`;
        return {
          contents,
          resolveDir: path__namespace.dirname(file),
          loader: "js"
        };
      });
    }

  };
}
/**
 * This plugin substitutes an empty module for any modules in the `app`
 * directory that match the given `filter`.
 */


function emptyModulesPlugin(config, filter) {
  return {
    name: "empty-modules",

    setup(build) {
      build.onResolve({
        filter
      }, args => {
        let resolved = path__namespace.resolve(args.resolveDir, args.path);

        if ( // Limit this behavior to modules found in only the `app` directory.
        // This allows node_modules to use the `.server.js` and `.client.js`
        // naming conventions with different semantics.
        resolved.startsWith(config.appDirectory)) {
          return {
            path: args.path,
            namespace: "empty-module"
          };
        }
      });
      build.onLoad({
        filter: /.*/,
        namespace: "empty-module"
      }, () => {
        return {
          // Use an empty CommonJS module here instead of ESM to avoid "No
          // matching export" errors in esbuild for stuff that is imported
          // from this file.
          contents: "module.exports = {};",
          loader: "js"
        };
      });
    }

  };
}
/**
 * This plugin loads route modules for the server build.
 */


function serverRouteModulesPlugin(config) {
  return {
    name: "server-route-modules",

    setup(build) {
      let routeFiles = new Set(Object.keys(config.routes).map(key => path__namespace.resolve(config.appDirectory, config.routes[key].file)));
      build.onResolve({
        filter: /.*/
      }, args => {
        if (routeFiles.has(args.path)) {
          return {
            path: args.path,
            namespace: "route-module"
          };
        }
      });
      build.onLoad({
        filter: /.*/,
        namespace: "route-module"
      }, async args => {
        let file = args.path;
        let contents = await fs.promises.readFile(file, "utf-8"); // Default to `export {}` if the file is empty so esbuild interprets
        // this file as ESM instead of CommonJS with `default: {}`. This helps
        // in development when creating new files.
        // See https://github.com/evanw/esbuild/issues/1043

        if (!/\S/.test(contents)) {
          return {
            contents: "export {}",
            loader: "js"
          };
        }

        return {
          contents,
          resolveDir: path__namespace.dirname(file),
          loader: loaders.getLoaderForFile(file)
        };
      });
    }

  };
}
/**
 * This plugin marks paths external using a callback function.
 */


function manualExternalsPlugin(isExternal) {
  return {
    name: "manual-externals",

    setup(build) {
      build.onResolve({
        filter: /.*/
      }, args => {
        if (isExternal(args.path, args.importer)) {
          return {
            path: args.path,
            external: true
          };
        }
      });
    }

  };
}

exports.build = build;
exports.watch = watch;
